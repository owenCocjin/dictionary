#!/bin/bash

#Author: Owen Cocjin
#Version: 0.2
#Update notes:
#		Fixed saving issues/sorting method

## ---------- FUNCTIONS -----------#
function usage(){
	echo -e '''
\e[33mUsage:\e[0m dictionary [-wth] [VALUES] \e[3mWORD\e[0m
\tFind the definition of a word

\e[33mArguments\e[0m:
\t-h, --help\tPrints this screen
\t-w,\t\tSets argument to word to be search. Default usage takes priority over this flag (see examples)
\t-t,\t\tFor testing!
\t-s,\t\tSaves the word in a local dictionary

\e[33mExamples:\e[0m
\tdictionary hot
\tdictionary -w cold hot
\t\t\e[2mIn the above case, hot will be searched\e[0m
\tdictionary -s hot
\tdictionary -w hot -s -t
	'''
	exit 0
}

function error(){
	err="$1"
	if [[ -z "$1" ]]; then
		err="Unknown Error!"
	fi
	echo -e "\e[31;1m[\e[34m|\e[31mX]\e[0m Error: $err"
	exit 1
}

## ------ VARIABLES --------- ##
word=""
local_dict='0'
save='0'
for lastArg in "$@"; do :; done #Assigns $lastArg the last argument
site="merriam-webster.sh"
utils="/home/$USER/.dictionary"

## -------- CHECKING FOR DIRECTORIES ---------- ##
if [[ ! -d /tmp/dictionary ]]; then
	mkdir /tmp/dictionary
	cat /dev/null > /tmp/dictionary/dict_file
fi

#Create dict_file
if [[ -f /tmp/dictionary/dict_file ]]; then
	cat /dev/null > /tmp/dictionary/dict_file
else
	touch /tmp/dictionary/dict_file
fi

#Create d file
if [[ -f /tmp/dictionary/d ]]; then
	cat /dev/null > /tmp/dictionary/d
else
	touch /tmp/dictionary/d
fi

#Create pipe
mkfifo /tmp/dictionary/dict_pipe 2>/dev/null
if [[ "$?" != '0' ]]; then
	:
fi
direct="/tmp/dictionary/"

## ------- CATCHING FLAGS ------- ##
while getopts ":w:thds" opts; do
	case $opts in
		w)
			if [[ "${OPTARG:0:1}" == '-' ]]; then
				usage
			fi
			word=$OPTARG
		;;
		t)
			direct="./"
		;;
		s)
			save=1
		;;
		d)
			local_dict=1
		;;
		h|-|*)
			usage
		;;
	esac
done
cd $direct

#If only one argument/first arg doesn't start with '-', assume it was the word
#Alternatively, if no argument is given, throw up usage
#Usage if no word was given
if [[ "$#" == '0' ]]; then
	usage
elif [[ "$#" == '1' ]] && [[ "${1:0:1}" != '-' ]]; then
	word="$1"
elif [[ "${lastArg:0:1}" != '-' ]]; then
	word="$lastArg"
elif [[ -z "$word" ]]; then
	usage
fi

## -------- MAIN -------- ##
#Get the word html
curl -L https://www.merriam-webster.com/dictionary/$word > dict_file 2>/dev/null
if [[ "$?" == '6' ]]; then
	error "curl could not resolve host (Check internet connection)"
	#echo -n "Use offline library (y/n)?: "
elif [[ "$?" == '0' ]]; then
	error
fi

if [[ "$direct" == './' ]]; then
	echo -n "Test detected! Use local files (y/n)?: "
	read rec
	if [[ "$rec" == 'y' ]]; then
		:
	else
		/home/$( whoami )/.dictionary/Sites/$site
		:
	fi
else
	/home/$( whoami )/.dictionary/Sites/$site
fi

#Assign the variables
rec=$( cat dict_pipe )
pronunciation=$( echo "$rec" | awk -F':' '{print $1}' )' \'
partOfSpeach=$( echo "$rec" | awk -F':' '{print $2}' )

#Print the results all formatted and pretty :D
echo -e """
\e[1mWord:\e[0m\t\e[5m$word\e[0m
\t\e[2m$pronunciation
\t$partOfSpeach\e[0m
\n\e[1mDefinition(s):\e[0m\
"""
awk '{print "\t"NR") "$0} END {print ""}' d

#Saves the word and sorts, if -s flag is passed.
#Send sort command into the background to prevent terminal from stalling
if [[ "$save" == '1' ]]; then
	echo "Saving..."
	toSave=""
	toSave+=$word":"$pronunciation":"$partOfSpeach":"
 	toSave+=$( awk '{printf "%s:",$0} END {print "\n"}' d )
	lineNo=$( grep -n "$word" /home/$USER/.dictionary/saved_words.txt | awk -F':' '{print $1}' )
	if [[ lineNo != '' ]]; then
		echo $toSave >> /home/$USER/.dictionary/saved_words.txt
		sort -o $utils/saved_words.txt $utils/saved_words.txt &
	fi
	echo "Saved!"
fi
